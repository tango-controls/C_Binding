#pragma rtGlobals = 2
#pragma IgorVersion = 6.0

//==============================================================================
// Fichier...scan_example_1.ipf (part of the beamline template)
// Date......02/2009
// Author....NL-SOLEIL
//==============================================================================

//==============================================================================
// ABOUT THIS EXAMPLE...
//==============================================================================
//- In this scan implementation example, the "actuator" is the gap (or phase) 
//- position of a HU80 insertion device (ID). The main "sensor" is an image read 
//- from a video grabber (VG). The machine current is also stored at each step 
//- of the scan.
//------------------------------------------------------------------------------
//- The main loop is quite simple: for each scan step, send the ID to the "next" 
//- gap (or phase) position. Once the ID is at the requested value, read the gap 
//- (or phase) back in order to get its "actual" (i.e. "real") value. Then, it 
//- is time to read the image on the video-grabber and the machine current .
//------------------------------------------------------------------------------
//- You will also find some code alllowing the user to browse/explore the data
//- from a previous acquisition. This is given as an example of "post data 
//- treatment automation" in which the daq (i.e. scan) data is easily retrieved 
//- thanks to the clean organization/structure of the data folder in which the
//- scan data is has been stored.
//------------------------------------------------------------------------------

//==============================================================================
// ENABLE/DISABLE HARDWARE ACESS (FOR TEST PURPOSE)
//==============================================================================
//- You can comment/decomment the following #define statements to switch between 
//- "online/offline" configuration. This provides you with a way to test the 
//- "logic part" of your code without a living TANGO control system. Each device 
//- involved in the scan has its own #define so that you can enable ctrl for some 
//- devices while others are disaled. 
//------------------------------------------------------------------------------
//- enable/disable TANGO ctrl of the HU80 insertion device (disabled here)
//#define ENABLE_HU80_CTRL
//- enable/disable TANGO ctrl of the video grabber (disabled here)
//#define ENABLE_VG_CTRL
//- enable/disable TANGO ctrl of the Machine Status (disabled here)
//#define ENABLE_MS_CTRL
//------------------------------------------------------------------------------

//==============================================================================
// DEVICE SUBSTITUTION (USE THE TANGOTEST DEVICE FOR TEST PURPOSE)
//==============================================================================
//- In case you have a living TANGO control system on your desk machine, you
//- can substitute a <TangoTest> device for the video grabber. The idea is to 
//- "see something close to reality" while testing the code. We control the 
//- device substitution using a #define statement. Here <USE_TANGOTEST> means
//- read/get the sensor image on a TangoTest device instead of reading it from
//- the video grabber.
//------------------------------------------------------------------------------
#define USE_TANGOTEST //- enabled here
	
//==============================================================================
// DEPENDENCES (INCLUDE PROCEDURE FILES USED BY THE LOCAL FUCNTIONS)
//==============================================================================
//- Include required procedure files here. It's the good place to include 
//- device (or class) interfaces generated by the tango binding!
//------------------------------------------------------------------------------
//- include tango stuffs
#include "tango"
#include "tango_tools"
//- include HU80 ID procedure file
#ifdef ENABLE_HU80_CTRL
#include "C:my-procedures:my-devices:HU80"
#endif
//- include video grabber procedure file
#ifdef ENABLE_VG_CTRL
#include "C:my-procedures:my-devices:VideoGrabber"
#endif
//- include machine status procedure file
#ifdef ENABLE_MS_CTRL
#include "C:sbl:procedures:my-devices:MachineStatus"
#endif
//- include TangoTest interface in case we want to substitute it for the VG
#ifdef USE_TANGOTEST
#include "C:my-procedures:my-devices:TangoTest"
#endif

//==============================================================================
// DEBUG FLAG
//==============================================================================
//- Define DEGUG flag when when developping/testing the code. For instance
//- we don't want the code to be unloaded when killing the last "sc1" window 
//- when working on the code. The DEBUG flag will help us to do so. We can also 
//- use the DEBUG flag to print out some debug log into Igor's history while
//- debugging the code. Just comment the following line to disable debugging 
//- code.
//------------------------------------------------------------------------------
#define DEBUG

//==============================================================================
// CONSTANTs
//==============================================================================
//- Here are some constants used in this procedure file. Each constant is
//- declared static in order to limit its "visibility" to the THIS procedure
//- file. See them as some kind of "procedure private data".
//==============================================================================
//- HU80 scan mode: GAP or PHASE (0 means GAP SCAN, 1 means PHASE SCAN)
//------------------------------------------------------------------------------
static constant kGAP_MODE = 0
static constant kPHASE_MODE = 1
//------------------------------------------------------------------------------
//- HU80 min/max values of the gap range
//------------------------------------------------------------------------------
static constant kMIN_GAP = 15.5 
static constant kMAX_GAP = 240 
//------------------------------------------------------------------------------
//- HU80 min/max gap step values
//------------------------------------------------------------------------------
static constant kMIN_GAP_STEP = 0.1 
static constant kMAX_GAP_STEP = 10 
//------------------------------------------------------------------------------
//- HU80 min/max values of the phase range
//------------------------------------------------------------------------------
static constant kMIN_PHASE = -43.35 
static constant kMAX_PHASE =  40.35
//------------------------------------------------------------------------------  
//- HU80 min/max values phase step 
//------------------------------------------------------------------------------
static constant kMIN_PHASE_STEP = 0.1  
static constant kMAX_PHASE_STEP = 10  
//------------------------------------------------------------------------------
//- VG image size in pixels (this should be dynamic - i.e. not hardcoded)
//------------------------------------------------------------------------------
#ifdef ENABLE_VG_CTRL
static constant kVG_IMG_W = 659
static constant kVG_IMG_H = 494
#else 
static constant kVG_IMG_W = 251
static constant kVG_IMG_H = 251
#endif
//------------------------------------------------------------------------------
//- name of TANGO devices involved in the scan (put "real" device names here)
//------------------------------------------------------------------------------
#ifdef ENABLE_HU80_CTRL
static strconstant kHU80_DEV = "my/hu80/device"
#endif
#ifdef ENABLE_VG_CTRL
static strconstant kVIDEO_GRABBER_DEV = "my/vg/device"
#endif
#ifdef ENABLE_MS_CTRL
static strconstant kMACHINE_STATUS_DEV = "my/ms/device"
#endif
#ifdef USE_TANGOTEST
static strconstant kTANGOTEST_DEV = "tango/tangotest/1"
#endif
//------------------------------------------------------------------------------
//- exec period of the background task in ticks (60 ticks approx = 1 sec)
//------------------------------------------------------------------------------
static constant kBCKG_TASK_PERIOD = 15

//==============================================================================
// fonction: sc1_scan_init_df 
//==============================================================================
//- this function - which is called from <sc1_gui_open_panel> - creates the df
//- (datafolder) where the scan configuration parameters are stored. here we 
//- choose to store them into <root:sbl:sc1>
//==============================================================================
static function sc1_scan_init_df ()
	//- save current datafolder
	String previous_df = GetDataFolder(1)
	//- create then set as active the scan datafolder (!!example dependent!!)
	tools_df_make("root:sbl:sc1:", 1)
	//- scan status: ctrl flag (set to 1 - i.e. "true" - while a scan is in progress)
	Variable/G scan_in_progress = 0
	//- scan status: current point (or step) of the running the scan
	Variable/G cur_point = 0
	//- scan status: timestamp of last HU80 positioning request 
	Variable/G last_pos_request_ts = ticks
	//- scan status: HU80 pos monitor
	Variable/G pos_mon
	//- scan status: image window of the current scan
	String/G img_win = ""
	//- scan cfg: df in which the scan data will be stored
	String/G scan_df = ""
	//- scan cfg: mode - defaults to GAP mode
	Variable/G mode = kGAP_MODE
	//- scan cfg: start point (GAP is the default mode)
	Variable/G from = kMIN_GAP
	//- scan cfg: end point (GAP is the default mode)
	Variable/G to = kMAX_GAP
	//- scan cfg: step (GAP is the default mode)
	Variable/G step = kMIN_GAP_STEP
	//- scan cfg: scan name/identifier
	String/G scan_suffix = num2str(1)
	//- restore initial df
	SetDataFolder previous_df 
	print "Scan Example I::env. setup done"
end
//==============================================================================
// fonction : sc1_scan_start
//==============================================================================
//- this function - starts a new scan taking into account the current value of
//- the scan configuration parameters stored in <root:sbl:sc1>.
//==============================================================================
function sc1_scan_start(ctrl)
	String ctrl
	//- get a reference to each scan config parameter
	NVAR from = root:sbl:sc1:from
	NVAR to = root:sbl:sc1:to
	NVAR step = root:sbl:sc1:step
	NVAR scan_mode = root:sbl:sc1:mode
	SVAR scan_suffix = root:sbl:sc1:scan_suffix
	SVAR scan_df = root:sbl:sc1:scan_df
	//- build scan datafolder name (where acquired data will be stored)
	//- name is something like: "root:sc1_sc1_gscan_" + a user defined suffix 
	//- specified from <sc1_panel>.
	switch (scan_mode)
		case kGAP_MODE:
			scan_df = "root:sc1_gscan_" + scan_suffix + ":"
			break
		case kPHASE_MODE:
			scan_df = "root:sc1_pscan_" + scan_suffix + ":"
			break
	endswitch
	//- does this datafolder already exist? 
	//-	 ask user to confirm twice before overwriting any existing data...
	if (DataFolderExists(scan_df))
			DoAlert 1,"The destination datafolder already exists. Overwrite?"
			switch (V_Flag)
				case 1:
					DoAlert 1,"Warning. This will delete any existing data. Continue anyway?"
					if (V_Flag == 2)
						return -1
					endif
					break
				case 2:
					return -1
					break
			endswitch
			//- kill existing df and its content (tool-function from tango_tools.ipf)
			tools_df_delete(scan_df)
	endif		
	//- save current datafolder (i.e. remember where we were in order to restore 
	//- the situation later in code. that's very important. boring but important!
	String previous_df = GetDataFolder(1)
	//- create destination datafolder and make it active (tool-function from tango_tools.ipf)
	tools_df_make(scan_df, 1)
	//- compute the num of points in the scan
	Variable npts
	npts = trunc((max(to,from) - min(to,from)) / step)	
	//- build the destination wave for HU80 gap or phase
	Variable signed_step = (to > from) ? step : (-1 * step)
	switch (scan_mode)
		case kGAP_MODE:
			Make /O /N=(npts + 1) hu80_gap = from + p * signed_step
			break
		case kPHASE_MODE:
			Make /O /N=(npts + 1) hu80_phase = from + p * signed_step
			break
	endswitch
	//- build a wave to store the machine current (measured at each step of the scan)
	Make/O/N=(npts + 1) machine_current = 0
	//- create a variable in the scan df to store the scan mode. this will ease post-scan 
	//- data manipulation and treatment
	Variable /G mode = scan_mode
	//- do the same for the scan suffix (needed by the data-explorer)
	//- this will also ease post-scan data treatment!
	String /G suffix = scan_suffix
	//- create an empty/dummy image in order to open the scan display 
	//- just a trick to have "something" into the graph before reading the 
	//- first image on the VG device
	Make/O/U/W/N=(128,128) current_beam_image = 0
	if (WaveExists(current_beam_image) == 0)
		//- oops, fatal error!
		DoAlert 0, "Make operation failed for video grabber image storage!"
		//- disable/enable <sc1_panel> controls
		sc1_gui_update_panel_ctrls()
		//- restore previous active data folder
		SetDataFolder previous_df
		//- exit function and tell the world we have a problem...
		return kERROR
	endif
	//- acquired VG images are stored into a 3D wave - let's make it...
	//- we could find a way to obtain the image size from the VG but we choose 
	//- use the fact that we know the size of the image provided by the VG 
	//- see kVG_IMG_W and kVG_IMG_H constants
	Make /O/U/W/N=(kVG_IMG_W, kVG_IMG_H, npts + 1) beam_images
	if (WaveExists(beam_images) == 0)
		//- oops, fatal error!
		DoAlert 0, "Make operation failed for <beam images> storage!"
		//- disable/enable <sc1_panel> controls
		sc1_gui_update_panel_ctrls()
		//- restore previous active data folder
		SetDataFolder previous_df
		//- exit function and tell the world we have a problem...
		return kERROR
	endif
	//- start a tango monitor in order to update the HU80 position while it is moving
	//- this will provide a way to monitor the HU80 position between two scan points.
	//- the associated value (i.e. the HU80 gap or phase) is displayed into a dedicated
	//- SetVariable located in the image window. 
#ifdef ENABLE_HU80_CTRL
	//- tell the monitor where we want the monitored value to go (i.e. in which df)
	String hu80_pos_path = "root:sbl:sc1:pos_mon"
	//- which attribute should we monitor? gap or phase?
	String attribute_to_monitor
	switch (mode)
		case kGAP_MODE:
			attribute_to_monitor = "gap"
			break
		case kPHASE_MODE:
			attribute_to_monitor = "phase"
			break
	endswitch
	//- start a 2 Hz monitor and get our client identifier (cid) 
	Variable cid = tango_monitor_start(kHU80_DEV, attribute_to_monitor, hu80_pos_path, 500)  
	//- we need to retreive the client id later in the code so we attach it to the image 
	//- window as a "user data". this is a very nice Igor feature. however, we can only
	//- attach strings to an object. consequently, we have to convert the "cid" (which 
	//- is a numeric value) into a string (see <num2str> doc). 
	SetWindow $win_name, userdata(mon_cid) = num2str(cid)
#endif //- ENABLE_HU80_CTRL
	//------------------------------------------------------------------------------
	//- here begins the initialization/setup process of the TANGO devices involved 
	//- in the scan. you will see that it is (very) important to know how each device 
	//- works and behaves. you should at least know what each "state" means for a given 
	//- device. the video grabber (VG) is a good example. this device is "CLOSED" by 
	//- default (no link to underlying hardware at startup). moreover, once opened, 
	//- it must be started to grab images (RUNNING state). so, we might have to switch 
	//- the VG to the RUNNING state. <vgGetState,vgOpen, vgXxxx> functions come from 
	//- the procedure file generated by the TANGO binding (device class interface). 
	//------------------------------------------------------------------------------
#ifdef ENABLE_VG_CTRL
	//- make sure the video grabber is opened and started
	//- let's start by reading its current TANGO state 
	Variable vg_state
	print "Scan Example I::start::reading VG state..."
	if (vgGetState(kVIDEO_GRABBER_DEV, vg_state) == kERROR)
		//- oops! there is something wrong with the device
		tango_display_error()
		//- exit function and tell the world we have a problem...
		return kERROR
	endif 
	print "Scan Example I::start::VG state is: " + tango_get_state_str(vg_state)
	//- if VG is in <kDeviceStateCLOSE> state the open it...
	if (vg_state == kDeviceStateCLOSE)
		print "Scan Example I::start::executing <Open> command on VG"
		//- exec <Open> command on VG device
		if (vgOpen(kVIDEO_GRABBER_DEV) == kERROR)
			tango_display_error()
	  		return kERROR
		endif 
		//- get "new" VG state
		if (vgGetState(kVIDEO_GRABBER_DEV, vg_state) == kERROR)
	  		return kERROR
		endif 
		//- should now be <kDeviceStateOPEN>
		if (vg_state != kDeviceStateOPEN)
			print "Scan Example I::start::<Open> command failed on VG - current state is: " + tango_get_state_str (vg_state)
			tango_display_error()
	  		return kERROR
		endif 
	endif
	//- otherwise, if VG is in <kDeviceStateOPEN> state then start it...
	if (vg_state == kDeviceStateOPEN)
		print "Scan Example I::start::executing <Start> command on VG"
		//- exec <Start> command on VG device
		if (vgStart(kVIDEO_GRABBER_DEV) == kERROR)
			tango_display_error()
	  		return kERROR
		endif 
		//- get "new" VG state
		if (vgGetState(kVIDEO_GRABBER_DEV, vg_state) == kERROR)
			tango_display_error()
	  		return kERROR
		endif 
		//- should now be <kDeviceStateRUNNING>
		if (vg_state == kDeviceStateRUNNING)
			print "Scan Example I::start::<Start> command failed on VG - current state is: " + tango_get_state_str (vg_state)
			tango_display_error()
	  		return kERROR
		endif
	endif
#endif //- ENABLE_VG_CTRL
#ifdef ENABLE_HU80_CTRL
	//- send the scan 'actuator' (i.e. gap or phase) to its first position
	Variable err = 0
	switch (mode)
		case kGAP_MODE:
			err = hu80SetGap(hu80_gap[0])
			break
		case kPHASE_MODE:
			err = hu80SetPhase(hu80_phase[0])
			break
	endswitch
	//- check error
	if (err == kERROR)
		//- an error occured while trying to send the HU80 to its first position
		//- display error
		tango_display_error()
		//- changed panel state (update,show or hide controls in the scan panel)
		sc1_panel_state()
		//- restore previous data folder
		SetDataFolder previous_df
		//- exit function and tell the world we have a problem...
		return kERROR
	endif
#endif //- ENABLE_HU80_CTRL
	//------------------------------------------------------------------------------
	//- ok. the devices are now up and ready...
	//- it's time to open the scan image display (your 'realtime' scan feedback). 
	//- first we build the image window name & window title
	//- remember: in Igor each object as a unique name. we need to control each 
	//- scan window name in order to identify from which window an action as been
	//- performed. for instance, if the user play with the "color scale menu", we
	//- must have a way to clearly identify the window or data on which the change
	//- should be applied. here we choose to name our window with the <sc1_gscan_> or
	//- <sc1_pscan_> prefix following by the user defined <scan_suffix> - which is 
	//- itself specified from the <sc1_pannel>.
	//------------------------------------------------------------------------------
	//- note: the current scan window name (i.e. name of the image window) is stored
	//- into a dedicated global string which path is root:sbl:sc1:img_win
	//------------------------------------------------------------------------------
	SVAR win_name = root:sbl:sc1:img_win
	String win_title
	switch (scan_mode)
		case kGAP_MODE:
			win_name = "sc1_gscan_" + scan_suffix
			win_title = "Diag.HU80::gscan::" + scan_suffix
			break
		case kPHASE_MODE:
			win_name = "sc1_pscan_" + scan_suffix
			win_title = "Diag.HU80::pscan::" + scan_suffix
			break
	endswitch
	//- open image display (current_beam_image is the name of the wave to display)
	//- the "open/setup display" code is encapsulated into a dedicated function
	//- so that it can be reused. the same mechanism (i.e. open sc1 data display) is
	//- required when we start a scan - that's what we are doing - and the user open
	//- a sc1 data explorer from the menu. we put the code into <sc1_gui_display_image>
	//- and place a call to it in both contexts (start scan and open data explorer).   
	sc1_gui_display_image(win_name, win_title, "current_beam_image")
	//- attach image wave name to the window (for easier retrival)
	SetWindow $win_name, userData(img_wname)=GetWavesDatafolder(current_beam_image, 2)
	//- attach scan datafolder to the window (for easier retrival)
	SetWindow $win_name, userData(scan_df)=scan_df
	//- attach scan suffix to the window (for easier retrival)
	SetWindow $win_name, userData(scan_suffix)=scan_suffix
	//- link the HU80 position to the <hu80_pos> SetVariable ctrl in the image window
	//- this variable will be updated by the tango monitor we started on the HU80 position
	//- we create it manually because it must exist to be able to attach it to a SetVariable
	NVAR hu80_pos  = root:sbl:sc1:pos_mon
	SetVariable hu80_pos, win=$win_name, value=hu80_pos
	//- link a value to the img-index ctrl and set its limits 
	Variable /G img_index = 0
	SetVariable img_index, win=$win_name, limits={0, npts, 1}, value=img_index
	//- link the machine current to the associated ctrl
	SetVariable mcurrent, win=$win_name, value=machine_current[0]
	//- ok we are done the GUI part. let's initialize the scan loop now...
	//- reset scan current point to 0 (first point in scan)
	NVAR cur_point = root:sbl:sc1:cur_point
	cur_point = 0
	//- scan status: initial HU80 'state checking timestamp' 
	NVAR last_pos_request_ts = root:sbl:sc1:last_pos_request_ts
	last_pos_request_ts = ticks
	//- setup background task: function
	SetBackGround sc1_scan_background()
	//- setup background task: excec period in ticks
	CtrlBackground period = kBCKG_TASK_PERIOD, noburst = 1
	//- mark scan as "running"
	NVAR scan_in_progress = root:sbl:sc1:scan_in_progress
	scan_in_progress = 1	
	//- switch the panel to its "scan running" state
	sc1_gui_update_panel_ctrls()
	//- setup background task: start
	CtrlBackground start
	//- restore the previous df
	SetDataFolder previous_df
	//- no error
	return 0
end
//==============================================================================
// fonction : sc1_scan_stop
//==============================================================================
static function sc1_scan_stop ()
	//- mark scan as "stopped"
	NVAR running = root:sbl:sc1:scan_in_progress
	running = 0
	//- get scan window name
	SVAR img_win = root:sbl:sc1:img_win
	//- 
#ifdef ENABLE_HU80_CTRL
	Variable mon_cid = str2num(GetUserData(img_win, "", "mon_cid"))
	tango_monitor_stop(kHU80_DEV, "*", cid = mon_cid)
#endif //- ENABLE_HU80_CTRL	
	//- display the first image and the first HU80 pos 
	sc1_img_index_changed (img_win, 0)
	//- show ctrls
	SetVariable img_index, win=$img_win, disable=0
	PopupMenu actions_menu,win=$img_win, disable=0 
	//- change panel ctrls state
	sc1_gui_update_panel_ctrls()
	return 0
end
//==============================================================================
// fonction : sc1_scan_abort
//==============================================================================
function sc1_scan_abort(ctrl) : ButtonControl
	String ctrl
	//- abort the background task
	CtrlBackground stop
	//- do the job we do in case of a "normal" stop (end of scan) 
	sc1_scan_stop()
	//- kill (i.e. remove) the HU80-pos and img-index ctrls
	SVAR img_win = root:sbl:sc1:img_win
	KillControl /W=$img_win hu80_pos
	KillControl /W=$img_win img_index
	//- delete scan df? keep the acquired data?
 	DoAlert 1,"Scan aborted. Delete scan data?"
	switch (V_Flag)
		case 1:
			SVAR scan_df = root:sbl:sc1:scan_df
			tools_df_delete(scan_df)
			break
	endswitch
end
//==============================================================================
// fonction : sc1_scan_background
//==============================================================================
function sc1_scan_background ()
	//- is the scan running?
	NVAR running = root:sbl:sc1:scan_in_progress
	if (running == 0)
		//- should never get here!
		//- return '1' in order to stop the background task
		return 1
	endif
	//- get timestamp of the last HU80 pos request 
	NVAR last_pos_request_ts = root:sbl:sc1:last_pos_request_ts
	//- check HU80 state (reached the requested pos?)
#ifdef DEBUG
	print "Scan Example I::bckg-task::checking state..."
#endif
	Variable hu80_state = kDeviceStateSTANDBY
#ifdef ENABLE_HU80_CTRL
	if (hu80State(hu80_state) == kERROR)
		//- an error occured while trying to read the HU80 state attribute
		tango_print_error()
		print "Scan Example I::bckg-task::aborting scan [HU80 read State error]"
		running = 0
		sc1_panel_state ()
		//- return '1' in order to stop the background task
		return 1
	endif
#endif //- ENABLE_HU80_CTRL
#ifdef DEBUG
	print "Scan Example I::bckg-task::HU80 state::" + tango_get_state_str(hu80_state)
#endif
	switch (hu80_state)
		//- MOVING: still moving toward the requested pos
		case kDeviceStateMOVING:
			//- we will be back soon...
			return 0
			break
		//- STANDBY: reached the requested pos
		case kDeviceStateSTANDBY:
			//- just break and execute the remaining code...
			break
		//- ALARM, FAULT: fatal error
		case kDeviceStateALARM:
		case kDeviceStateFAULT:
			print "Scan Example I::bckg-task::aborting scan [HU80 wrong state error]"
			running = 0
			sc1_gui_update_panel_ctrls ()
			//- return '1' in order to stop the background task
			return 1
			break
		default:
			//- unexpected HU80 state - treat this as a fatal error
			print "Scan Example I::bckg-task::unexpected state::aborting scan [HU80 unknown state error]"
			running = 0
			sc1_gui_update_panel_ctrls()
			//- return '1' in order to stop the background task
			return 1
			break
	 endswitch		
	//- get current scan mode
	NVAR mode = root:sbl:sc1:mode
	//- the HU80 has reached its pos, it's time to read the 'actual' value
	Variable err = 0	
	Variable hu80_pos = 0
#ifdef ENABLE_HU80_CTRL
	switch (mode)
		case kGAP_MODE:
			err = hu80GetGap(hu80_pos)
			break
		case kPHASE_MODE:
			err = hu80GetGap(hu80_pos)
			break
	endswitch
	//- check error
	if (err == kERROR)
		//- an error occured while trying to read the current HU80 pos
		tango_display_error();
		print "Scan Example I::bckg-task::aborting scan [HU80 read gap or phase error]"
		running = 0
		sc1_panel_state ()
		//- return '1' in order to stop the background task
		return 1
	endif
#endif //- ENABLE_HU80_CTRL
	//- save current datafolder
	String previous_df = GetDataFolder(1)
	//- enter the scan df
	SVAR scan_df = root:sbl:sc1:scan_df
	SetDataFolder scan_df
	//- let's store the 'actual' value into the dedicated wave (at cur_point)
	NVAR cur_point = root:sbl:sc1:cur_point
	switch (mode)
		case kGAP_MODE:
			WAVE gw = hu80_gap
#ifdef DEBUG
			print "Scan Example I::bckg-task::requested pos: " + num2str(gw[cur_point]) + " actual pos: " + num2str(hu80_pos) 
#endif
#ifdef ENABLE_HU80_CTRL
			gw[cur_point] = hu80_pos
#endif
			break
		case kPHASE_MODE:
			WAVE pw = hu80_phase
#ifdef DEBUG
			print "Scan Example I::bckg-task::requested pos: " + num2str(pw[cur_point]) + " actual pos: " + num2str(hu80_pos) 
#endif
#ifdef ENABLE_HU80_CTRL
			pw[cur_point] = hu80_pos
#endif
			break
	endswitch
	//- read the machine current
	Variable current = 0
#ifdef ENABLE_MS_CTRL
	Variable current
	if (msGetCurrent(current) == kERROR)
		print "Scan Example I::bckg-task::aborting scan [Machine Status read error]"
		running = 0
		sc1_panel_state()
		SetDataFolder previous_df
		return 1
	endif
#endif
	//- store the current value into the dedicated wave
	WAVE mcw = machine_current
	mcw[cur_point] = current
	//- update machine current ctrl
	SVAR win_name = root:sbl:sc1:img_win
	SetVariable mcurrent, win=$win_name, value=mcw[cur_point]
	//- it's now time to read the image on the video grabber
	String image_destination = GetDataFolder(1) + "current_beam_image"
#ifdef ENABLE_VG_CTRL
	err = vgGetImage(kVIDEO_GRABBER_DEV, image_destination)
	//- check error
	if (err == kERROR)
		//- an error occured while trying to read the beam image
		print "Scan Example I::bckg-task::aborting scan [Video-Grabber read error]"
		running = 0
		sc1_panel_state()
		SetDataFolder previous_df
		return 1
	endif
#endif
#ifdef USE_TANGOTEST
	err = ttGetLong_image_ro(kTANGOTEST_DEV, image_destination)
	//- check error
	if (err == kERROR)
		//- an error occured while trying to read the beam image
		tango_print_error()
		print "Scan Example I::bckg-task::aborting scan [TangoTest read attr. error]"
		running = 0
		sc1_gui_update_panel_ctrls()
		SetDataFolder previous_df
		return 1
	endif
#endif //- ENABLE_VG_CTRL
	//- ok the image has been read into a local wave named '$image_destination'
	WAVE current_beam_image = :current_beam_image
	WAVE beam_images = :beam_images
	beam_images[][][cur_point] = current_beam_image[p][q]
	//- next point in scan... 
	cur_point += 1
	//- compare cur_point to the num of points in the scan
	Variable npts
	switch (mode)
		case kGAP_MODE:
			npts = numpnts(gw)
			break
		case kPHASE_MODE:
			npts = numpnts(pw)
			break
	endswitch
	//- did we reach the end of scan?
	if (cur_point == npts)
#ifdef DEBUG
		print "Scan Example I::bckg-task::end of scan"
#endif
		sc1_scan_stop()
		SetDataFolder previous_df
		return 1
	endif
	//- then send the HU80 to its next position
#ifdef ENABLE_HU80_CTRL
	switch (mode)
		case kGAP_MODE:
			err = hu80SetGap(gw[cur_point])
			break
		case kPHASE_MODE:
			err = hu80SetGap(pw[cur_point])
			break
	endswitch
	//- check error
	if (err == kERROR)
		running = 0
		sc1_panel_state ()
		SetDataFolder previous_df
		return 1
	endif	
#endif //- ENABLE_HU80_CTRL
	//- restore previous df
	SetDataFolder previous_df
	//- no error, background task continue...
	return 0	
end	
//==============================================================================
// function: sc1_gui_open_panel
//==============================================================================
//- This function opens the <sc1_panel> (the scan user interface) from which the
//- scan parameters are specified. It first takes care to check that the scan 
//- config datafolder exits - eventually creates it calling the <sc1_scan_init_df> 
//- function. It then built the graphical interface making links between scan 
//- parameters values store in sbl::sc1 and the controls (e.g. SetVariables). 
//==============================================================================
function sc1_gui_open_panel ()
	//- if the <sc1_panel> already exists then return (do not open it twice)
	String wl = WinList("sc1_panel",";","")
   if (strlen(wl) != 0)
   		//- already opened, just make it the "frontmost window"...
   		DoWindow /F sc1_panel
   		//- ...then return
   		return 0
   endif
	//- be sure the datafolder containing the scan "meta data" exists...
   if (DataFolderExists("root:sbl:sc1:") == 0)
   		//- ... create it otherwise
   		sc1_scan_init_df()
   endif
   //- create the scan panel and give it a name (very important) and a title.
   //- note the /K=1 then read NewPanel documentation!
	NewPanel /K=1 /W=(397,56,797,140) /N=sc1_panel as "Scan Example I"
	//- fixed size panel (can't be resized by user) 
	ModifyPanel /W=sc1_panel, fixedSize=1
	//- set the window hook in order to be able to handle window events (advanced prog.)
	SetWindow sc1_panel, hook(main)=sc1_gui_win_hook
	//- some group boxes for a good looking interface :-)
	GroupBox mode_box,pos={5,5},size={52,71},title="Mode"
	GroupBox settings_box,pos={60,5},size={258,71},title="Scan Settings"
	GroupBox ctrl_box,pos={321,5},size={75,71},title="Ctrl"
	//- create the controls and link them to their associated value or function
	//- scan cfg: scan mode (G or P)
	NVAR mode = root:sbl:sc1:mode
	CheckBox mode_gcbox,mode=1,pos={15,30},size={30,14},title="G"
	CheckBox mode_gcbox,proc=sc1_gui_mode_changed
	CheckBox mode_gcbox,value=((mode == kGAP_MODE) ? 1 : 0)
	CheckBox mode_pcbox,mode=1,pos={15,50},size={31,14},title="P"
	CheckBox mode_pcbox,proc=sc1_gui_mode_changed
	CheckBox mode_pcbox,value=((mode == kPHASE_MODE) ? 1 : 0)
	//- scan cfg: scan range: from 
	SetVariable from,pos={67,21}, size={119,16}, title="From", bodyWidth= 92
	SetVariable from,variable=root:sbl:sc1:from
	//- scan cfg: scan range: to 
	SetVariable to,pos={77,38},size={109,16},title="To",bodyWidth= 92
	SetVariable to,variable=root:sbl:sc1:to
	//- scan cfg: scan step
	SetVariable step,pos={68,56},size={118,16},title="Step",bodyWidth= 92
	SetVariable step,variable=root:sbl:sc1:step
	//- scan cfg: data folder name suffix of next acquisition
	SetVariable scan_suffix,pos={192,38},size={121,16},title="Suffix"
	SetVariable scan_suffix,variable=root:sbl:sc1:scan_suffix
	//- scan ctrls: sacn ctrl: start/abort button
	Button start_but,pos={328,36},size={60,22},proc=sc1_scan_start,title="Start"
	Button abort_but,pos={328,36},size={60,22},proc=sc1_scan_abort,title="Abort"
	NVAR running = root:sbl:sc1:scan_in_progress
	Button start_but,disable=((running) ? 1 : 0)
	Button abort_but,disable=((running) ? 0 : 1)
	//- simulate a change in scan mode to setup the controls properly
	sc1_mode_changed()
end
//==============================================================================
// fonction : sc1_gui_update_panel_ctrls
//==============================================================================
//- this function updates the <sc1_panel> controls according to the scan state
//- which is itself stored into the <root:sbl:sc1:scan_in_progress> variable
//==============================================================================
static function sc1_gui_update_panel_ctrls ()
	NVAR scan_in_progress = root:sbl:sc1:scan_in_progress
	if (scan_in_progress)
		Button start_but,win=sc1_panel,disable=1
		Button abort_but,win=sc1_panel,disable=0
		CheckBox mode_gcbox,win=sc1_panel,disable=2
		CheckBox mode_pcbox,win=sc1_panel,disable=2
		SetVariable from,win=sc1_panel,disable=2	
		SetVariable to,win=sc1_panel,disable=2	
		SetVariable step,win=sc1_panel,disable=2		
		SetVariable scan_suffix,win=sc1_panel,disable=2	
	else
		Button start_but,win=sc1_panel,disable=0
		Button abort_but,win=sc1_panel,disable=1
		CheckBox mode_gcbox,win=sc1_panel,disable=0
		CheckBox mode_pcbox,win=sc1_panel,disable=0
		SetVariable from,win=sc1_panel,disable=0
		SetVariable to,win=sc1_panel,disable=0	
		SetVariable step,win=sc1_panel,disable=0	
		SetVariable scan_suffix,win=sc1_panel,disable=0	
	endif
end
//==============================================================================
// fonction : sc1_gui_mode_changed
//==============================================================================
function sc1_gui_mode_changed (cbs)
	STRUCT WMCheckboxAction &cbs
	NVAR mode = root:sbl:sc1:mode
	strswitch (cbs.ctrlName)
		case "mode_gcbox":
			mode = (cbs.checked) ? kGAP_MODE : kPHASE_MODE
			break
		case "mode_pcbox":
			mode = (cbs.checked) ? kPHASE_MODE : kGAP_MODE
			break
	endswitch
	sc1_mode_changed()
end
//==============================================================================
// fonction : sc1_mode_changed
//==============================================================================
static function sc1_mode_changed ()
	NVAR mode = root:sbl:sc1:mode
	NVAR from = root:sbl:sc1:from
	NVAR to = root:sbl:sc1:to
	NVAR step = root:sbl:sc1:step
   String format_str
	Variable min_val
	Variable max_val
	Variable min_step_val
	Variable max_step_val
	String scan_prefix
	switch (mode)
		case kGAP_MODE:
			CheckBox mode_pcbox, win=sc1_panel, value=1
			CheckBox mode_pcbox, win=sc1_panel, value=0
			from = kMAX_GAP - 1
			to = kMAX_GAP
			step = 1 
			format_str = "%.2f mm";
			min_val = kMIN_GAP
			max_val = kMAX_GAP
			min_step_val = kMIN_GAP_STEP
			max_step_val = kMAX_GAP_STEP
			break
		case kPHASE_MODE:
			CheckBox mode_gcbox, win=sc1_panel, value=0
			CheckBox mode_pcbox, win=sc1_panel, value=1
			from = kMAX_PHASE - 1
			to = kMAX_PHASE
			step = 1
			format_str = "%.2f mm";
			min_val = kMIN_PHASE
			max_val = kMAX_PHASE
			min_step_val = kMIN_PHASE_STEP
			max_step_val = kMAX_PHASE_STEP
			break
	endswitch
	SetVariable from, win=sc1_panel, limits={min_val, max_val, min_step_val}
	SetVariable from, win=sc1_panel, format=format_str
	SetVariable to, win=sc1_panel, limits={min_val, max_val, min_step_val}
	SetVariable to, win=sc1_panel, format=format_str
	SetVariable step, win=sc1_panel, limits={min_step_val, max_step_val, min_step_val}
	SetVariable step, win=sc1_panel, format=format_str
end
//==============================================================================
// function: sc1_gui_win_hook
//==============================================================================
function sc1_gui_win_hook (ws)
	Struct WMWinHookStruct &ws
	Variable statusCode = 0
	switch (ws.eventCode)
		//- killvote event: can we close the panel now? might not be possible...
		case 17:
			//- if we have a <scan_in_progress> then we can't close the current 
			//- scan display window (i.e. image) nor the scan panel! 
			SVAR scan_win = root:sbl:sc1:img_win
			NVAR running = root:sbl:sc1:scan_in_progress
			Variable is_panel = ! cmpstr(ws.winName, "sc1_panel")
			Variable is_current_scan_img = ! cmpstr(ws.winName, scan_win)
			statusCode = (running && (is_panel ||is_current_scan_img)) ? 2 : 0
			break
		//- kill event: panel is about to be closed?
		case 2:
			//- unload this procedure file! if we can... means no more sc1 
			//- windows opened. don't unload procedure in debug mode!
#ifndef DEBUG
			if (sc1_can_unload_procedure(ws.winName))
				print "Scan Example I::unloading procedure..."
				Execute /Q/P "DELETEINCLUDE \"C:sbl:procedures:daq:scan_example_1\""
				Execute /Q/P "COMPILEPROCEDURES "
			endif
#endif
			break
	endswitch
	// 0 if nothing done, else 1
	return statusCode
end
//==============================================================================
// function: sc1_gui_display_image
//==============================================================================
static function sc1_gui_display_image (win_name, win_title, img_wave_name)
	String win_name
	String win_title
	String img_wave_name
	DoWindow/K $win_name
	Display /K=1 /W=(256.5,132.5,657,519.5) /N=$win_name
	DoWindow/F $win_name
	SetWindow $win_name, hook(main)=sc1_gui_win_hook
	AppendImage /W=$win_name $img_wave_name
	ModifyImage /W=$win_name $img_wave_name ctab={*,*,PlanetEarth,0}
	ModifyGraph /W=$win_name margin(top)=28,margin(right)=57
	ModifyGraph /W=$win_name axOffset(left)=-2.33333
	ModifyGraph /W=$win_name width={Aspect,1}, height={Aspect,1}
	ModifyGraph /W=$win_name wbRGB=(56797,56797,56797)
	ModifyGraph /W=$win_name mirror=1, minor=1
	ModifyGraph /W=$win_name font="Arial", fSize=8
	ModifyGraph /W=$win_name tickUnit(bottom)=1, tickUnit(left)=1
	DoWindow/T $win_name, win_title
	SetAxis/A/R left
	ColorScale /W=$win_name /N=text0 /F=0 /S=3 /B=1 /A=MC /X=43.95 /Y=0.40
	ColorScale /W=$win_name /N=text0 /E /C image=$img_wave_name, heightPct=100
	String cmd_str = "ColorScale /W=" + win_name
	cmd_str += "/C/N=text0 width=7,font=\"Small Fonts\",fsize=6,minor=1"
	Execute(cmd_str)
	AppendText "\\F'Arial'\\F'Arial'\\Z08\\Z06\\Z10\\F'Arial'\\Z10\\U"
	ControlBar 30
	PopupMenu color_table_popup,win=$win_name,pos={9,5},size={139,21},bodyWidth=80
	PopupMenu color_table_popup,win=$win_name,mode=7,value= #"\"*COLORTABLEPOPNONAMES*\""
	PopupMenu color_table_popup,win=$win_name,proc=sc1_gui_ctable_changed,title="Color Table",disable=0
	SetVariable hu80_pos,win=$win_name,pos={386,7},size={140,16},title="HU80 Pos."
	SetVariable hu80_pos,win=$win_name,format="%.2f mm",limits={0,0,0},noedit=1
	SetVariable img_index,win=$win_name,pos={264,7},size={110,16},title="Image Index",format="%g"
	SetVariable img_index,win=$win_name,limits={0,0,1},disable=1,proc=sc1_gui_img_index_changed 
	SetVariable mcurrent,pos={157,7},size={100,16},title="M.Cur.",format="%.2f mA"
	SetVariable mcurrent,limits={0,0,0},noedit= 1
	PopupMenu actions_menu,win=$win_name,pos={536,5},size={129,21},proc=sc1_gui_actions_changed,title="Actions",disable=1
	PopupMenu actions_menu,win=$win_name,mode=1,popvalue="Play Movie",value= #"\"Play Movie;Save Movie...;Save Images as Text...\""
	DoUpdate 
end
//==============================================================================
// function: sc1_gui_ctable_changed
//==============================================================================
function sc1_gui_ctable_changed (pua)
	STRUCT WMPopupAction &pua
	if (pua.eventCode != 2)
		return kNO_ERROR
	endif
	ControlInfo /W=$pua.win reverse_ct_cb
	ModifyImage /W=$pua.win ''#0 ctab={*, *, $pua.popStr, V_Value}
end
//==============================================================================
// function: sc1_gui_img_index_changed
//==============================================================================
function sc1_gui_img_index_changed (sva)
	STRUCT WMSetVariableAction &sva
	if (sva.eventCode != 1 && sva.eventCode != 2)
		return kNO_ERROR
	endif
	sc1_img_index_changed(sva.win, sva.dval)
	return 0
end
//==============================================================================
// function: sc1_gui_actions_changed
//==============================================================================
function sc1_gui_actions_changed (pa)
	STRUCT WMPopupAction &pa
	if (pa.eventCode != 2)
		return kNO_ERROR
	endif
	switch(pa.popNum)
		//- play movie
		case 1:
			sc1_gui_play_movie(pa.win)
			break
		//- save movie
		case 2:
			sc1_gui_save_movie(pa.win)
			break
		//- save images as text
		case 3:
			sc1_gui_save_img_as_text(pa.win)
			break
	endswitch

	return 0
end
//==============================================================================
// function: sc1_img_index_changed
//==============================================================================
function sc1_img_index_changed (win_name, img_index)
	String win_name
	Variable img_index
	String scan_path = GetUserData(win_name, "", "scan_df")
	NVAR mode = $scan_path + "mode"
	if (NVAR_Exists(mode) == 0)
		print "ERROR:there is no <mode> variable in " + scan_path
		return kERROR
	endif
	WAVE /Z beam_images = $scan_path + "beam_images"
	if (WaveExists(beam_images) == 0)
		print "ERROR:there is no <beam_images> wave in " + scan_path
		return kERROR
	endif
	if (mode == kGAP_MODE)
		WAVE /Z gap = $scan_path + "hu80_gap"	
		if (WaveExists(gap) == 0)
			print "ERROR:there is no <gap> wave in " + scan_path
			return kERROR
		endif
		SetVariable hu80_pos, win=$win_name, value=gap[img_index]
	else
		WAVE /Z phase = $scan_path + "hu80_phase"
		if (WaveExists(phase) == 0)
			print "ERROR:there is no <phase> wave in " + scan_path
			return kERROR
		endif
		SetVariable hu80_pos, win=$win_name, value=phase[img_index]
	endif
	WAVE /Z current_beam_image = $scan_path + "current_beam_image"
	if (WaveExists(current_beam_image) == 0)
		print "ERROR:there is no <current_beam_image> wave in " + scan_path
		return kERROR
	endif
	WAVE /Z mcw = $scan_path + "machine_current"
	if (WaveExists(mcw) == 0)
		print "ERROR:there is no <machine current> wave in " + scan_path
		return kERROR
	endif
	SetVariable mcurrent, win=$win_name, value=mcw[img_index]
	current_beam_image = beam_images[p][q][img_index]
	return 0
End
//==============================================================================
// function: sc1_gui_play_movie
//==============================================================================
function sc1_gui_play_movie (win_name)
	String win_name
	String scan_path = GetUserData(win_name, "", "scan_df")
	WAVE /Z mcw = $scan_path + "machine_current"
	if (WaveExists(mcw) == 0)
		print "ERROR:there is no <machine current> wave in " + scan_path
		return kERROR
	endif
	Variable npts = numpnts(mcw)
	NVAR/Z img_index =  $scan_path + "img_index"
	if (! NVAR_Exists(img_index))
		Variable/G img_index = 0
	endif
	Variable i
	for (i = 0; i < npts; i += 1)
		img_index = i
		sc1_img_index_changed (win_name, i)
		DoUpdate	
		Sleep/T 5 
	endfor 
end
//==============================================================================
// function: sc1_gui_save_img_as_text
//==============================================================================
function sc1_gui_save_img_as_text (win_name)
	String win_name
	String scan_path = GetUserData(win_name, "", "scan_df")
	if (! DataFolderExists(scan_path))
		DoAlert 0, "ERROR:there is no <" + scan_path + "> datafolder!"
		return kERROR
	endif
	String scan_suffix = GetUserData(win_name, "", "scan_suffix")
	NVAR mode = $scan_path + "mode"
	if (NVAR_Exists(mode) == 0)
		DoAlert 0, "ERROR:there is no <mode> variable in " + scan_path
		return kERROR
	endif
	if (mode == kGAP_MODE)
		WAVE /Z gap = $scan_path + "hu80_gap"	
		if (WaveExists(gap) == 0)
			DoAlert 0, "ERROR:there is no <gap> wave in " + scan_path
			return kERROR
		endif
	else
		WAVE /Z phase = $scan_path + "hu80_phase"
		if (WaveExists(phase) == 0)
			DoAlert 0, "ERROR:there is no <phase> wave in " + scan_path
			return kERROR
		endif
	endif
	WAVE /Z mcw = $scan_path + "machine_current"
	if (WaveExists(mcw) == 0)
		DoAlert 0, "ERROR:there is no <machine current> wave in " + scan_path
		return kERROR
	endif
	WAVE/Z current_beam_image = $scan_path + "current_beam_image"
	if (WaveExists(current_beam_image) == 0)
		DoAlert 0, "ERROR:there is no <current_beam_image> wave in " + scan_path
		return kERROR
	endif
	Variable i
	Variable npts = numpnts(mcw)
	String mc_str
	String mc_value_str
	String pos_str 
	String pos_value_str
	String file_name
	KillPath/Z sc1_save_path
	NewPath/C/O/M="Destination folder" sc1_save_path
	PathInfo sc1_save_path
	if (! V_Flag)
		return 0
	endif
	String save_cmd_prefix = "Save/G /P=sc1_save_path "
	for (i = 0; i < npts; i += 1)
		file_name = "sc1-"
		mc_value_str = num2str(mcw[i])
		if (mode == kGAP_MODE)
			file_name += "sc1-gscan-"
			pos_value_str = num2str(gap[i])	
		else
			file_name += "sc1-pscan-"
			pos_value_str = num2str(phase[i])
		endif
		file_name += scan_suffix + "-i" + num2str(i)
		mc_value_str = sc1_gui_remove_dot(mc_value_str)
		pos_value_str = sc1_gui_remove_dot(pos_value_str)
		if (mode == kGAP_MODE)
			file_name += "-g"
		else
			file_name += "-p"
		endif
		file_name += pos_value_str + "-mc" + mc_value_str + ".txt"
		print "DiagHU80::saving image <" + num2str(i) + "> as " + file_name
		sc1_img_index_changed (win_name, i)
		Execute save_cmd_prefix + GetWavesDataFolder(current_beam_image, 2) + " as \"" + file_name + "\""
	endfor
	String mc_file_name
	String hu80_pos_file_name
	String hu80_pos_wave_path
	if (mode == kGAP_MODE)
		mc_file_name = "sc1-gscan-" + scan_suffix + "-machine-current.txt"
		hu80_pos_file_name = "sc1-gscan-" + scan_suffix + "-gap.txt"
		hu80_pos_wave_path = GetWavesDataFolder(gap, 2)
	else
		mc_file_name = "sc1-pscan-" + scan_suffix + "-machine-current.txt"
		hu80_pos_file_name = "sc1-pscan-" + scan_suffix + "-phase.txt"
		hu80_pos_wave_path = GetWavesDataFolder(phase, 2)
	endif
	Execute save_cmd_prefix + GetWavesDataFolder(mcw, 2) + " as \"" + mc_file_name + "\""
	Execute save_cmd_prefix + hu80_pos_wave_path + " as \"" + hu80_pos_file_name + "\""
	return 0 
end
//==============================================================================
// function: sc1_gui_remove_dot
//==============================================================================
//- just a local helper function. its job is to replace by an underscore the dot 
//- (or comma) of a floating point value passed as a string. this function is
//- called from <sc1_gui_save_img_as_text> when building the image file name. 
//------------------------------------------------------------------------------
static function/S sc1_gui_remove_dot (value_str)
	String value_str
	String substitute
	Variable pos = strsearch(value_str, ".", 0)
	if (pos == -1)
		return value_str
	endif
	String no_dot_str = value_str[0, pos - 1] + "_" + value_str[pos + 1, strlen(value_str) - 1]
	return no_dot_str
end
//==============================================================================
// function: sc1_gui_open_data_explorer
//==============================================================================
//- opens a so called "data explorer" to explore the data stored in a scan data
//- folder (i.e. a "previous" acquisition).     
//------------------------------------------------------------------------------
function sc1_gui_open_data_explorer ()
	//- save current datafolder
	String previous_df = GetDataFolder(1)
	//- select the df in which the data is stored
	String scan_path = tools_df_select()
	//- user canceled selection?
	if (! strlen(scan_path))
		return 0
	endif
	//- enter the selected datafolder
	SetDataFolder scan_path
	//- be sure everything is there: mode variable
	NVAR/Z mode = :mode
	if (! NVAR_Exists(mode))
		DoAlert 0, "ERROR:there is no <mode> variable in " + scan_path
		SetDataFolder previous_df
		return kERROR
	endif
	//- be sure everything is there: gap or phase wave
	if (mode == kGAP_MODE)
		WAVE/Z gap = :hu80_gap
		if (! WaveExists(gap))
			DoAlert 0, "ERROR:there is no <gap> wave in " + scan_path
			SetDataFolder previous_df
			return kERROR
		endif
	else
		WAVE/Z phase = :hu80_phase
		if (! WaveExists(phase))
			DoAlert 0, "ERROR:there is no <phase> wave in " + scan_path
			SetDataFolder previous_df
			return kERROR
		endif
	endif
	//- be sure everything is there: machine current wave
	WAVE/Z mcw = :machine_current
	if (! WaveExists(mcw))
		DoAlert 0, "ERROR:there is no <machine current> wave in " + scan_path
		SetDataFolder previous_df
		return kERROR
	endif
	//- be sure everything is there: beam_images
	WAVE/Z beam_images = :beam_images
	if (! WaveExists(beam_images))
		DoAlert 0, "ERROR:there is no <beam_images> wave in " + scan_path
		SetDataFolder previous_df
		return kERROR
	endif
	//- be sure everything is there: current_beam_image wave
	WAVE/Z cur_beam_image = :current_beam_image
	if (! WaveExists(current_beam_image))
		Variable np = DimSize(beam_images, 0) 
		Variable nq = DimSize(beam_images, 1) 
		Make/O/U/W/N=(np,nq) current_beam_image = beam_images[p][q][0]
		cur_beam_image = current_beam_image
	endif
	//- be sure everything is there: scan suffix
	SVAR/Z scan_suffix = :scan_suffix
	if (! SVAR_Exists(scan_suffix))
		String /G scan_suffix = UniqueName("scan", 6, 0)
	endif
	//- be sure everything is there: image index
	NVAR/Z img_index = :img_index
	if (! NVAR_Exists(img_index))
		Variable/G img_index = 0
	endif
	//- let's open the scan image display 
	//- first we build the image window name & window title
	String win_name
	switch (mode)
		case kGAP_MODE:
			win_name = UniqueName("sc1_gscan_" + scan_suffix, 6, 0)
			break
		case kPHASE_MODE:
			win_name = UniqueName("sc1_pscan_" + scan_suffix, 6, 0)
			break
	endswitch		
	String win_title = "Diag.HU80::" + GetDataFolder(0)
	//- open image display
	sc1_gui_display_image(win_name, win_title, "current_beam_image")
	//- attach image wave name to the window (for easier retrival)
	SetWindow $win_name, userData(img_wname)=GetWavesDatafolder(cur_beam_image, 2)
	//- attach scan datafolder to the window (for easier retrival)
	SetWindow $win_name, userData(scan_df)=scan_path
	//- attach scan suffix to the window (for easier retrival)
	SetWindow $win_name, userData(scan_suffix)=scan_suffix
	//- attach a value to the img-index ctrl and set its limits 
	Variable /G img_index = 0
	SetVariable img_index, win=$win_name, limits={0, numpnts(mcw) - 1, 1}, value=img_index
	//- show ctrls
	SetVariable img_index, win=$win_name, disable=0
	PopupMenu actions_menu,win=$win_name, disable=0 
	//- display the first image and the first HU80 pos 
	sc1_img_index_changed (win_name, 0)
	//- restore previous datafolder
	SetDataFolder previous_df
end
//==============================================================================
// function: sc1_gui_save_movie
//==============================================================================
function sc1_gui_save_movie (win_name)
	String win_name
	String scan_path = GetUserData(win_name, "", "scan_df")
	if (! DataFolderExists(scan_path))
		DoAlert 0, "ERROR:there is no <" + scan_path + "> datafolder!"
		return kERROR
	endif
	String scan_suffix = GetUserData(win_name, "", "scan_suffix")
	NVAR mode = $scan_path + "mode"
	if (NVAR_Exists(mode) == 0)
		DoAlert 0, "ERROR:there is no <mode> variable in " + scan_path
		return kERROR
	endif
	if (mode == kGAP_MODE)
		WAVE /Z gap = $scan_path + "hu80_gap"	
		if (WaveExists(gap) == 0)
			DoAlert 0, "ERROR:there is no <gap> wave in " + scan_path
			return kERROR
		endif
	else
		WAVE /Z phase = $scan_path + "hu80_phase"
		if (WaveExists(phase) == 0)
			DoAlert 0, "ERROR:there is no <phase> wave in " + scan_path
			return kERROR
		endif
	endif
	WAVE /Z mcw = $scan_path + "machine_current"
	if (WaveExists(mcw) == 0)
		DoAlert 0, "ERROR:there is no <machine current> wave in " + scan_path
		return kERROR
	endif
	WAVE/Z current_beam_image = $scan_path + "current_beam_image"
	if (WaveExists(current_beam_image) == 0)
		DoAlert 0, "ERROR:there is no <current_beam_image> wave in " + scan_path
		return kERROR
	endif
	NVAR/Z img_index =  $scan_path + "img_index"
	if (! NVAR_Exists(img_index))
		Variable/G img_index = 0
	endif
	Variable i
	Variable npts = numpnts(mcw)
	String mc_value_str
	String pos_value_str
	KillPath/Z sc1_gui_save_movie_path
	NewPath/C/O/M="Destination folder" sc1_gui_save_movie_path
	PathInfo sc1_gui_save_movie_path
	if (! V_Flag)
		return 0
	endif
	String file_name = "sc1-"
	if (mode == kGAP_MODE)
		file_name += "gscan-"
	else
		file_name += "pscan-"
	endif
	file_name += scan_suffix	
	NewMovie /Z /F=2 /O /L /P=sc1_gui_save_movie_path as file_name
	if (V_Flag)
		DoAlert 0, "NewMovie failed!"
		return 0
	endif
	for (i = 0; i < npts; i += 1)
		img_index = i
		sc1_img_index_changed(win_name, i)
		mc_value_str = "Machine Current = " + num2str(mcw[i]) + " mA"
		if (mode == kGAP_MODE)
			pos_value_str = "HU80 gap = " + num2str(gap[i]) + " mm" 
		else
			pos_value_str = "HU80 phase = " + num2str(phase[i]) + " mm" 
		endif
		print "DiagHU80::adding frame <" + num2str(i) + "> to the movie"
		TextBox/K/N=text1
		TextBox/C/N=text1/X=0/Y=0 "\\Z08\\F'Courier New'" +  mc_value_str + " - " + pos_value_str
		DoUpdate
		AddMovieFrame 
	endfor
	CloseMovie
	TextBox/K/N=text1
	return 0 
end
//==============================================================================
// function : sc1_can_unload_procedure
//==============================================================================
static function sc1_can_unload_procedure (from_window)
	//- the window for which the <sc1_gui_win_hook> as been called
	String from_window 
	//- here (in this function) we try to answer the question: "can we unload this
	//- procedure?" - we can do so in case there are no more opened "sc1 windows" 
	//- i.e. there are no more opened window using code located into the present 
	//- procedure file. 
	//- a "sc1 window" - the daq panel or any sc1 image dipslay - is "linked" to 
	//- the <sc1_gui_win_hook> function. it means that we must keep the code (i.e.
	//- the procedure) loaded till there is no more "sc1 windows" opened. any 
	//- "sc1 window" is named with the prefix "sc1_". if the list of opened windows 
	//- which name matches the "sc1_" prefix is not empty, then we can't unload the code. 
	//- simple! not so simple because the win-hook function (and consequently this 
	//- function) is called while the <from_window> is still "opened". it will always 
	//- appear in the window list. think about it... it also means that the <WinList> 
	//- will never be empty and we will never get a change to unload the procedure!  
	//- so it gives...
	String match_str = "sc1_*"	
	String win_list = WinList(match_str, ";", "")
	from_window += ";" 
	if (cmpstr(win_list, from_window) == 0)
		return 1;
	endif
	return 0 
end 
